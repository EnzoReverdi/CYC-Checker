#!/usr/bin/perl
# use strict;
# use warnings;
use File::Find;
   
$verbos = 1;
$no_warnings = 0;
$warning_threshold = 30;
$no_mod = 0;

if ($#ARGV >= 0) {
	my $i = 0;
	my $n = 0;
	while ( $i <= $#ARGV ) {
		if ($ARGV[$i] eq "-s") {
			$verbos = 0;
		} elsif ( $ARGV[$i] eq "-help" ) {
			showhelp();
		} elsif ( $ARGV[$i] eq "-no-warn" ) {
			$no_warnings = 1;
		} elsif ( $ARGV[$i] eq "-no-mod" ) {
			$verbos = 1;
			$no_mod = 1;
		} elsif ( $ARGV[$i] eq "-warn" ) {
			if ( $i + 1 > $#ARGV ) {
					print "ERROR: Missing option for arg '-warn'!\n";
					showhelp();
			} else {
				if ( $ARGV[ $i + 1 ] !~ /^\d+$/ ) {
					print "ERROR: '-warn' option should be an int!\n";
					showhelp();
				} elsif ( $ARGV[ $i + 1 ] < 1 ) {
					print "ERROR: '-warn' option should be > 0!\n";
					showhelp();
				}
				$warning_threshold = $ARGV[ $i + 1 ];
				$i++;
			}
		} else {
			print "ERROR: Arg '$ARGV[$i]' unknow!\n";
			showhelp();
		}
		$i++
	}
	
}

find(
{
    wanted => \&findfiles,
},
'.'
);

sub showhelp
{
	print "Usage: ./cycheck [arg] [option] ...\n";
	print "Possible arg:\n";
	print "\t-help: show this help\n";
	print "\t-s: Disable the output on STDOUT, Warning still gonna appear\n";
	print "\t-no-warn: Disable the warnings generated on STDOUT\n";
	print "\t-no-mod: Open File on read-only and will not append the Checker result on the files\n";
	print "\t-warn: Specifie when Warning should be generated by the int gived as option after it, default is 30\n";
	exit 1;
}

sub findfiles
{
	# if ($File::Find::name =~ m/\.cpp$/) {} else { return; }
    open my $info, $File::Find::name or return;

    my $in_function = 0;
    my $nb_brackets_open = 0;
    my $nb_brackets_closed = 0;
    my $nb_and = 0;
    my $nb_or = 0;
    my $nb_if = 0;
    my $nb_lineBuff = 0;
    my $func_name = "";
	my $fn_already = 0;

    while( my $line = <$info>)  {
        if ($in_function == 2) {
            $func_name = $line;
            $in_function = 1;
        }
        if ($in_function == 1) {
            $nb_brackets_open += findSymbols($line, "{");
            $nb_if += findSymbols($line, " if ");
            $nb_if += findSymbols($line, "	if ");
            $nb_if += findSymbols($line, " if(");
            $nb_if += findSymbols($line, "	if(");
            $nb_and += findSymbols($line, "&&");
            $nb_or += findSymbols($line, "\\|\\|");
            $nb_brackets_closed += findSymbols($line, "}");
            if ($nb_brackets_open != 0 && $nb_brackets_open == $nb_brackets_closed) {
                my $res = $nb_if + $nb_and + $nb_or + 1;
				if ( $verbos ) {
					if ( !$fn_already ) {
						$fn_already = 1;
						print "$File::Find::name\n";
					}
					if ( $res >= $warning_threshold && !$no_warnings ) {
						system('echo -en "\x1b[31m  WARNING  \x1b[4m$1\x1b[0m"');
					} else {
						print "           ";
					}
					print "$res  $func_name";
				} elsif ( !$no_warnings and $res >= $warning_threshold ) {
					if ( !$fn_already ) {
						$fn_already = 1;
						print "$File::Find::name\n";
					}
					system('echo -en "\x1b[31m  WARNING  \x1b[4m$1\x1b[0m"');
					print "$res  $func_name";
				}
				if ( !$no_mod ) {
					open(DATA, "+<$File::Find::name");
					seek DATA, $nb_lineBuff, 0;
					if ( $res < 10 ) {
						print DATA "0";
					}
					print DATA "$res]\n";
					close (DATA);
				}
                $func_name = "";
                $in_function = 0;
                $nb_brackets_open = 0;
                $nb_brackets_closed = 0;
                $nb_and = 0;
                $nb_or = 0;
                $nb_if = 0;
                $nb_lineBuff = 0;
            }
        }
        if ($line =~ m/^(\/\/ CYC CHECKER: \[([0-9]{2}|##)\])$/) {
            $nb_lineBuff = tell $info;
			$nb_lineBuff = $nb_lineBuff - 4;
            $in_function = 2;
        }
    }
    close $info;
    print "\n" if $verbos && $fn_already;
}

sub findSymbols {
    my $pat = quotemeta $_[1];
    my $n = () = ($_[0] =~ m/$pat/g);
    return $n;
}